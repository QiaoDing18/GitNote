title: 浏览器渲染过程
author: 乔丁
tags:
  - 闲聊
categories:
  - chat
date: 2018-04-27 19:23:00
---


## 一些引擎
1、浏览器引擎：用来查询及操作渲染引擎的接口
2、渲染引擎：用来查询及操作渲染引擎的接口
3、UI后端：用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。
4、JS解释器：用来解释执行JS代码

## 页面生成过程
1、DNS服务器通过域名查找对应的Web服务器ip地址
2、浏览器访问Web服务器（三次握手）
3、服务器处理完成 返回html
4、浏览器解析、加载页面
	解析html构建dom树 -> 构建渲染树 -> 布局渲染树 -> 绘制渲染树

浏览器为了体验友好，并不是文档全部都解析才绘制到屏幕上，而是从上至下开始解析html，遇到css 会开启线程下载css
解析：
1、将html构建成一个DOM树，DOM树的构建过程是一个深度遍历过程：当前结点的所有子节点都构建好后才会去构建当结点的下一个兄弟结点
2、将css解析成css去构造cssom树（cssom=css对象模型）
3、根据DOM树和cssom来构造渲染树。渲染树并不等同于DOM树，因此一些像Header或者display:none的东西就不会出现在渲染树中。
4、有了渲染树，浏览器已经能知道网页中有哪些结点、各个节点的css定义以及他们的从属关系
5、下一步操作会是布局，顾名思义就是计算每个节点在屏幕中的位置布局渲染树
6、绘制，遍历渲染树，并使用浏览器UI后端层绘制每个节点

性能优化中重绘、重排
（1）Reflow（回流/重排）：当它发现了某个部分发生了变化影响了布局，渲染树需要重新计算。
（2）Repaint（重绘）：改变了某个元素的背景颜色、文字颜色等。不影响元素周围或内部布局的属性，将只会引起浏览器的重绘，根据元素的新属性重新绘制，使元素呈现新的外观。重绘不会重新布局，并不一定伴随重排

  
*上面的有点乱：*
1、浏览器接收到html代码，自上而下解析：构建DOM树+构建css对象模型=》渲染树
2、遇到script文件和css文件都会另起线程去下载；内嵌的script标签和style标签，会直接执行，分别阻塞DOM树和css规则树
3、无论内嵌的script脚本、外链的script脚本下载都会阻塞构建DOM树；css文件执行和内嵌的style标签阻塞css对象模型
4、直到DOM树和css对象模型规则生成完毕后，浏览器结合两者生成渲染树，浏览器将渲染树绘制到页面上，首次显示页面
5、最后body底部的JS脚本下载完成后通过DOM API修改DOM，通过css对象模型 API修改样式，每次修改都会造成渲染树的重排和重绘。

*注意*
1、把js放在body之后，是为了预防外部js文件过多，浏览器呈现页面出现延迟，延迟期间浏览器的窗口一片空白 
2、当遇到script文件加载/执行*会阻塞后面DOM树的构建*（因为js可能会改变DOM树）而遇到css文件则*会阻塞渲染树的构建*，即DOM树依然继续构建（除非遇到script标签并且css文件依旧未加载完成），但不会渲染绘制到页面上。而无论哪个阻塞，该加载的文件还是会加载，例如html文档中的其他css/js/图片文件
3、js脚本放在head和body有什么区别
head中的脚本会在页面加载之前解析，可以保证脚本在任何调用之前被加载
body中的脚本会在页面加载完成之后读取，放在body部分的脚本通常被用来生成页面的内容。因为加载js脚本会阻塞页面的加载，为了用户体验也为了脚本可以正常操作DOM，一般放在body中
浏览器解析html是从上到下的
如果把js放在head里的话，则先被解析，但这时候body还没有解析，所以会返回空值。一般都会绑定一个监听，当全部的html文档解析完之后，在执行代码：windows.onload

*总之*：
内嵌和外链js脚本，都会阻塞DOM树的构建；
style标签和css文件，都会阻塞css对象模型的构建

1、计算CSS样式
2、构建Render Tree
3、Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 
4、正式开画

Repaint——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。
Reflow——意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow ）reflow 会从html这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。

导致重排
1、当你增加、删除、修改DOM结点时，会导致Reflow或Repaint
2、当你移动DOM的位置，或是搞个动画的时候。
3、当你修改CSS样式的时候。
4、当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。
5、当你修改网页的默认字体时。

优化办法：
1、不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className
2、不要把DOM结点的属性值放在一个循环里当成循环里的变量
3、为动画的DOM使用fixed或absolute的position：不会重排，脱离文档流
4、不使用table布局：table中一个小的改动会造成整个table的重新布局


*script的async和defer属性*
async，立即下载，异步操作，即合加载和渲染后续文档元素的过程并行进行，也就是异步，一起操作
defer，立即下载，延迟解析，可以延迟到文档完全被解析和显示之后再执行

相同点：
1、加载文件时不阻塞页面渲染
2、使用这两个属性的脚本中不能调用document.write方法
3、允许不定义属性值，仅仅使用属性名
不同点：
1、支持程度不一样async是h5
2、每一个async属性的脚本都在它下载结束之后立即执行，同时会在window的load事件之前执行，所以就有可能出现脚本执行顺序被打乱的情况
3、每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行