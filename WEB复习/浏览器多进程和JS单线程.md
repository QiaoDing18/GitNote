title: 浏览器多进程和JS单线程（硬件加速）
author: 乔丁
tags:
  - 闲聊
categories:
  - chat
date: 2018-04-27 17:22:00
---


# 进程和线程区别
*进程*：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
*线程*：线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

# 浏览器是多进程的
1、浏览器是多进程的
2、浏览器之所以能够运行，是因为系统给他的进程分配了资源（cpu、内存）
3、每次打开一个Tab页，就相当于创建了一个独立的浏览器进程

## 浏览器有哪些进程
1、浏览器进程：浏览器的主进程（负责协调、主控），只有一个，作用：
	（1）负责浏览器界面显示，与用户交互。如前进后退
	（2）负责各个页面的管理，创建和销毁其他进程
	（3）绘制到用户界面上
	（4）网络资源的管理，下载等
2、第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
3、GPU进程：最多一个，用于3D绘制等
4、浏览器渲染进程：每个页面一个进程，互不影响。主要控制页面渲染，脚本执行，事件处理等

## 浏览器多进程优势
如果浏览器是单线程，如果某个Tab页崩溃了，就影响了整个浏览器，体检就很差。如果是单线程，插件崩溃了也会影响整个浏览器

## 浏览器内核！important
主要常驻线程：
**1、GUI渲染线程**
	（1）负责渲染浏览器界面，解析HTML，CSS，构建DOM树和渲染对象树，布局和绘制等
	（2）当界面需要重绘或由于某种操作引发回流时，该线程就会执行
	（3）注意，GUI渲染线程与JS引擎线程是互斥的，**当引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行**
**2、JS引擎线程**
	（1）也成为JS内核，负责处理JS脚本程序，JS引擎负责解析JS脚本，运行代码
	（2）JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（即是一个渲染进程）中无论什么时候都只有一个JS线程在运行JS程序
	（3）*GUI渲染线程和JS引擎线程是互斥的*，**所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞**
**3、事件触发线程**
	（1）归属于浏览器而不是JS引擎，用来控制事件循环（注意是浏览器另开的线程协助）
	（2）当JS引擎执行代码块如setTimeout时（也可能是来自浏览器内核的其他线程，如鼠标点击，AJAX异步请求等），会将对应人物添加到事件线程中
	（3）当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
	（4）由于JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理（JS引擎空闲时候才会去执行）
**4、定时触发线程**
	（1）传说中的setInterval和setTimeout所在的线程
	（2）浏览器定时计数器并不是由JS引擎计数的，（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时器的准确性）
	（3）因此通过单线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
	（4）W3C规定setTimeout有最小时间间隔4ms
**5、异步http请求线程**
	（1）XHR在连接后是通过浏览器新开一个线程请求
	（2）将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调函数再放入事件队列中。再由JS引擎执行



## 关于JS单线程和事件（任务）队列
任务两种：同步、异步
*同步任务*：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
*异步任务*：不进入主线程、而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行

异步执行机制：
1、所有同步任务都在主线程上执行，形成一个执行栈
2、主线程之外，还存在一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件
3、一旦执行栈中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4、主线程不断重复上面操作

*event loop*
主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）



  
主线程运行的时候，产生堆和栈，栈中的代码调用各种外部API，它们在“任务队列”中加入各种事件（click,load,done）。只要栈中的代码执行完毕，主线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。

*定时器*
除了放置异步任务的事件，“任务队列”还可以放置定时器事件，即指定某些代码在多少时间之后执行。
*定时器中回调执行的代码永远在其他代码执行之后，因为他被放到了事件队列中，只有主线程执行完之后才会执行“任务队列”中的回调函数*
总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。

*Node的 Event Loop*
Node提供了process.nextTick和setImmediate
*process.nextTick*方法可以在当前“执行栈”的尾部————下一次Event Loop（主线程读取“任务队列”）之前————触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。他总比时间队列里快，比setTimeout永远快
*setImmediate*方法则是在当前“任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行。和setTimeout(fn, 0)很像
*process.nextTick和setImmediate的一个重要区别*
**多个process.nextTick语句总是在当前"执行栈"一次执行完，多个setImmediate可能则需要多次loop才能执行完。**

实上，这正是Node.js 10.0版添加setImmediate方法的原因，否则像下面这样的递归调用process.nextTick，将会没完没了，主线程根本不会去读取"事件队列"！
process.nextTick(function foo() {
  process.nextTick(foo);
});

## 浏览器控制进程和浏览器内核的通信
上面扯了事件队列，再回到浏览器里

浏览器两个进程：一个主控进程，一个打开Tab页的渲染进程

1、控制进程收到用户请求，首先需要获取页面的内容，随后将该任务通过接口传给渲染进程
2、渲染进程的渲染接口收到消息，简单解释后，交给渲染线程，然后开始渲染
	（1）渲染线程开始渲染，加载网页并渲染页面。其中需要控制进程获取资源和需呀GPU进程来帮助渲染
	（2）会有JS线程操作DOM，这样造成重排重绘
	（3）最后渲染进程将结果传给控制进程
3、控制进程接收到结果并将结果绘制

# 整理一下之间的关系
## GUI渲染线程与JS引擎线程互斥
由于JS是可操作DOM的，如果在修改这些元素属性同时渲染界面，*或者说JS线程和UI线程同时运行，那么渲染线程前后获得的元素数据可能不一致了*
因为为了防止渲染出现不可预估的结果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行

## JS阻塞页面加载
从上可见，JS如果执行时间过长就会阻塞页面
假如JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存在队列中，等到JS引擎空闲后执行，然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡
所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉

可以使用webWorker去进行巨量计算，关于webWorker
1、创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
2、JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象与线程交互特定的数据）

所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!

# 再梳理一下渲染流程

1、解析html构建DOM树
2、解析css构建render树（将css代码解析成树形的数据结构，然后结合DOM合并成render树）
3、布局render树（Layout\reflow），负责各元素尺寸、位置的计算
4、绘制render树（paint），绘制页面像素信息
5、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

## load事件与DOMContentLoaded事件的先后
1、当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)

2、当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）

## css加载是否会阻塞dom树渲染？
1、头部引入css
css是单独的下载线程异步现在的
	（1）css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
	（2）但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

因为你加载css的时候，可能会修改下面DOM节点的样式， 如果css加载不阻塞render树渲染的话，那么当css加载完之后， render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。 **所以干脆就先把DOM树的结构先解析完**，把可以做的工作做完，**然后等你css加载完之后， 在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点**。

## EventLoop
几个线程：
1、JS引擎线程
2、事件触发线程
3、定时器触发线程

几个概念：
1、JS分为同步任务和异步任务
2、同步任务都在主线程上执行，形成一个执行栈
3、主线程之外，事件触发器线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件
4、一旦执行栈中所有的同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行

## 定时器线程
有单独的定时器线程
定时器线程是将事件于多少时延后放入事件队列，主线程没任务后会在EventLoop机制的情况下去执行事件队列中的定时器的回调函数
setInerval有累计效应，如果setInterval再次添加到队列之前其他的事件还么执行完，就会导致定时器代码连续运行好几次，而之间没有时间间隔。就算正常运行，多个setInterval的代码执行时间可能会比与其的小（因为代码执行需要一定时间）

而且把浏览器最小化显示等操作时，setInterval并不是不执行程序， 它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时

## Promise和事件循环机制
Promise会先比setTimeout执行
有两种新的任务类型：macrotask和microtask
*macrotask*：宏任务（task）。每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
	（1）每个task会从头到尾将这个任务执行完毕，不会执行其他
	（2）浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染（task->渲染->task->...）
*microtask*：微任务（jobs）。当前task执行结束后立即执行的任务
	（1）也就是说，在当前task任务后，下一个task之前，在渲染之前
	（2）所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
	（3）也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

*分别很么样的场景会形成macrotask和microtask呢？*
macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）

microtask：Promise，process.nextTick等
补充：在node环境下，*process.nextTick的优先级高于Promise*，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。
另外，setImmediate则是规定：*在下一次Event Loop（宏任务）时触发（所以它是属于优先级较高的宏任务）*， （Node.js文档中称，setImmediate指定的回调函数，总是排在setTimeout前面）， 所以setImmediate如果嵌套的话，是需要经过多个Loop才能完成的， 而不会像process.nextTick一样没完没了。

macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护

microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护

**机制总结**
1、执行一个宏任务（栈中没有就从事件队列中获取）
2、执行过程中如果遇到微任务，就将他添加到微任务的任务队列中
3、宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4、当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5、渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
