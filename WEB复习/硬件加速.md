title: 某讯的硬件加速
author: 乔丁
tags:
  - 闲聊
categories:
  - chat
date: 2018-05-1 15:32:00
description: 硬件加速小结
photos: http://p7wm7amg2.bkt.clouddn.com/3.png
---

劳动节假期宣告了春招的结束（对我来说）
投简历时候看到了这个 http://join.qq.com 
![](http://p7wm7amg2.bkt.clouddn.com/3.png)
打开这个网页，大概也就是几秒功夫，我的小办公本的风扇就开始叫唤了

对比一下打开前后的区别
之前：
![打开之前](http://p7wm7amg2.bkt.clouddn.com/1.png)
之后：
![打开之后](http://p7wm7amg2.bkt.clouddn.com/4.png)

emmmm  流弊

控制台点开，点了下这个
![](http://p7wm7amg2.bkt.clouddn.com/5.png)
然后
![](http://p7wm7amg2.bkt.clouddn.com/6.png)

嗯，硬件加速的锅了

![](http://p7wm7amg2.bkt.clouddn.com/9.png)

css3动画中大量运用了translate3d，用chrome提供的查看复合图层的这个功能可以看到有很多层

每个图层GPU单独绘制，过多会导致资源消耗过多，就会很卡了
这里总结一下这方面的知识

## 普通图层和复合图层
可以这样理解，浏览器渲染的图层一般包含两大类：普通图层、复合图层
首先，普通文档流可以理解为一个复合图层，在文档流中不管添加多少元素，其实都是在同一个复合图层中
其次，absolute、fix布局，虽然可以脱离普通文档流，但还是属于默认复合层

通过硬件加速的方式，会声明一个新的复合图层，它会单独**分配资源**
它也是肯定脱离普通文档流的，这样不管复合图层中怎么变化，也不会影响默认复合层里的回流重绘
可以这样理解，GPU中各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒

## 如何变成复合图层
将该元素变成一个复合图层，就是传说中的硬件加速技术
1、最常用的方法：translate3d、translateZ
2、opacity属性\过度动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
3、will-change属性，一般配合opacity与translate使用，作用是提前告诉浏览器要变化，这样浏览器会开始做一下优化工作
4、video、iframe、canvas、webgl、svg
5、其它，譬如以前的flash插件
6、元素有一个包含复合层的后代节点（换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里）
7、元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）


如果有一个元素，他的兄弟元素在复合层中渲染，而这个兄弟元素的z-index比较小，那么这个元素（不管有没有用到硬件加速样式）都会被放到复合层中

## 问题
在webkit css3中，如果这个元素添加了硬件加速，**并且index层级比较低，那么在这个元素后面其他元素（层级比这个元素高的，或者相同的，并且relative或absolute属性相同的），会默认变为复合层渲染**
用z-index让它高一点就解决了

简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意