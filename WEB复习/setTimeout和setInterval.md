title: setTimeout和setInterval
author: 乔丁
tags:
  - 前端
categories:
  - web
date: 2018-04-27 16:44:00
photos: http://p7wm7amg2.bkt.clouddn.com/time.png
---



js是单线程的！！！
定时器只是让代码在未来某个时间执行，执行时机是不保证的，因为在页面的生命周期中，不同时间可能有其他代码在控制js进程。在页面下载完成后的代码运行、时间处理程序、Ajax回调函数都必须使用同样的线程执行

浏览器负责进行排序，指派某段代码在某个时间点运行的优先级

JS代码没有任何代码是立即执行的，但一旦进程空闲则尽快进行

定时器队列的工作方式是，当特定时间过去后将代码插入。但是给队列添加代码不意味着对它立即执行，只是尽快执行。设**定一个时间，表示在这段时间后代码被加入到队列中**。如果这个时间上队列没有任何其他东西，那么这段代码就会被执行。

setInterval创建的定时器代码可能在再次被添加时，之前的代码队列还没执行完，结果导致定时器代码连续运行好几次，而之间没有停顿 
对于这种情况，当使用setInterval定时器时，**仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中**。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。	

问题：1、某些间隔会被跳过  2、多个定时器的代码执行之间的间隔可能会比预期的小
比如*定时器代码执行的时间超过了预定的时间间隔，冲突的定时器代码将不会被添加到队列中*。也有可能添加进去后由于时间接近就马上执行了。

为了避免这个情况，使用链式的setTimeout好
setTimeout(function(){
	setTimeout(arguments.callee, time);
}, time);
arguments.callee 这个属性相当于一个指针，指向拥有这个arguments对象的函数

这样就可以在一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。
而且，它可以保证在下一次定时器代码执行完之前，至少要等待指定的间隔，避免了连续运行。

# requestAnimationFrame
requestAnimationFrame 比起 setTimeout、setInterval的优势主要有两点：
1、*requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘中就完成*，并且*重绘或回流的时间间隔紧紧跟随浏览器的刷新频率*，一般来说，频率是每秒60帧
2、在隐藏或不可见的元素中，requestAnimationFrame将不会重绘或者回流，减少渲染情况

window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器**在下一次重绘之前调用指定的函数来更新动画**。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。

requestAnimationFrame会在JS执行栈结束后执行（也在Promise之后），再之后执行任务队列中放到JS执行栈中的任务

返回值：一个 long 整数，且非0，请求 ID ，是回调列表中唯一的标识。你可以传这个值给 window.cancelAnimationFrame() 以取消回调函数。


